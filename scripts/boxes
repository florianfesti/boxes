#!/usr/bin/env python3
"""boxes.py

Generate stencils for wooden boxes.

Usage:
  boxes [--watch] <generator> [<args>...]
  boxes --list
  boxes (-h | --help)
  boxes --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --list        List available generators.
  --watch       Watch generator file for changes and regenerate if changed.
"""

import importlib
import logging
import os
import sys
import time
import traceback

from docopt import docopt
from pkg_resources import get_distribution
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

import boxes.generators

try:
    import boxes
except ImportError:
    sys.path.append(os.path.dirname(os.path.realpath(__file__)) + '/..')
    import boxes

################################################################################

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

################################################################################


class GeneratorEventHandler(FileSystemEventHandler):
    def __init__(self, generator, generator_args):
        super().__init__()
        self.generator = generator
        self.generator_args = generator_args

    def on_modified(self, event):
        if not event.src_path == self.generator.module.__file__:
            return

        rerun_generator(self.generator, self.generator_args)


################################################################################


def main():
    __version__ = get_distribution('boxes').version
    version_str = 'boxes.py v{}'.format(__version__)
    args = docopt(__doc__, version=version_str, options_first=True)

    if args['--list']:
        list_grouped_generators()
    elif args['<generator>'] is not None:
        generator_command(args)


def list_grouped_generators():
    print('Available generators:')
    for group in generator_groups():
        print('\n' + group.title)
        if group.description:
            print('\n%s\n' % group.description)
        else:
            print()
        for box in group.generators:
            print(' *  {}  -  {}'.format(box.__name__, box.__doc__ or ''))


def generator_groups():
    generators = generators_by_name()
    return group_generators(generators)


def generators_by_name():
    all_generators = boxes.generators.getAllBoxGenerators()

    return {
        name.split('.')[-1].lower(): generator
        for name, generator in all_generators.items()
    }


def group_generators(generators):
    groups = boxes.generators.ui_groups
    groups_by_name = boxes.generators.ui_groups_by_name

    for name, generator in generators.items():
        group_for_generator = groups_by_name.get(generator.ui_group,
                                                 groups_by_name['Misc'])
        group_for_generator.add(generator)

    return groups


def generator_command(args):
    generator_name = args['<generator>']
    generator_args = args['<args>']

    generator = get_generator_or_exit(generator_name)
    run_generator(generator, generator_args)

    if args['--watch']:
        log_to_stderr()
        watch_generator(generator, generator_args)


def get_generator_or_exit(name):
    try:
        return get_generator(name)
    except KeyError:
        msg = ('Unknown generator \'{}\'. Use boxes --list to get a list of '
               'available commands.\n').format(name)
        sys.stderr.write(msg)
        sys.exit(1)


def get_generator(name):
    return generators_by_name()[name.lower()]


def run_generator(generator, args):
    logger.debug('Running generator \'%s\'', generator.__name__)
    box = generator()
    box.parseArgs(args)
    box.render()
    logger.debug('Finished running generator')


def log_to_stderr():
    handler = logging.StreamHandler()
    handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '%(asctime)s [%(levelname)s] %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)


def watch_generator(generator, args):
    logger.info('Watching generator \'%s\' for changes', generator.__name__)

    event_handler = GeneratorEventHandler(generator, args)
    generator_path = generator.module.__file__
    generator_dir = os.path.dirname(generator_path)

    observer = Observer()
    observer.schedule(event_handler, generator_dir)
    observer.start()

    watch_loop(observer)
    observer.join()


def watch_loop(observer):
    try:
        while True:
            time.sleep(0.1)
    except KeyboardInterrupt:
        logger.info('Received keyboard interrupt. Exiting.')
        observer.stop()


def rerun_generator(generator, args):
    logger.info('Generator has been modified. Regenerating.')
    generator = reload_generator(generator)

    try:
        run_generator(generator, args)
    except Exception as e:
        logger.error('Failed running generator:\n%s', traceback.format_exc())


def reload_generator(generator):
    importlib.reload(generator.module)
    return get_generator(generator.__name__)


if __name__ == '__main__':
    main()
